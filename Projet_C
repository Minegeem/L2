#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Dimensions de la grille en nombre de cases (origine en haut a gauche) :
#define COLONNES 12
#define LIGNES 18

// Les deux camps :
#define ABEILLE 'A'
#define FRELONCAMP 'F'

// Les types d'unites :
#define REINE 'r'
#define OUVRIERE 'o'
#define ESCADRON 'e'
#define GUERRIERE 'g'
#define FRELON 'f'
#define RUCHE 'R'
#define NID 'N'

// Pour la recolte de pollen
#define RECOLTE 'p'

// Les temps necessaires a la production :
#define TREINEA 8
#define TREINEF 8
#define TOUVRIERE 2
#define TGUERRIERE 4
#define TESCADRON 6
#define TFRELON 5
#define TRECOLTE 4


// Les couts necessaires a la production :
#define CREINEA 7
#define CREINEF 8
#define COUVRIERE 3
#define CGUERRIERE 5
#define CESCADRON 6
#define CFRELON 3
#define CRUCHE 10
#define CNID 10

// La force des unites
#define FREINE 6
#define FOUVRIERE 1
#define FGUERRIERE 5
#define FESCADRON 12
#define FFRELON 8

// La structure Unite :
typedef struct unite {
  char camp; // ABEILLE ou FRELON
  char type; // RUCHE, NID, REINE, OUVRIERE, GUERRIERE, ESCADRON ou FRELON
  int force; // la force de l'unite
  int posx, posy; // position actuelle sur la grille
  int destx, desty; // destination (negatif si immobile)
  char production; // production d'une ruche ou d'un nid et RECOLTE pour la recolte de pollen
  int temps; // nombres de tours total pour cette production
  int toursrestant; // tours restant pour cette production
  struct unite *usuiv, *uprec; // liste des unites affiliees a une ruche ou un nid
  struct unite *colsuiv, *colprec; // liste des autres ruches ou nids (colonies) du même camp
  struct unite *vsuiv, *vprec; // liste des autres unites sur la meme case
} Unite, *UListe;



// La structure Case :
typedef struct {
  Unite *colonie; // S'il y a une ruche ou un nid sur la case
  UListe occupant; // les autres occupants de la case
} Case;

// La structure Grille :
typedef struct {
  Case plateau[LIGNES][COLONNES];
  UListe abeille, frelon;
  int tour; // Numero du tour
  int ressourcesAbeille, ressourcesFrelon;
} Grille;

//alloue une case
Case* init_case(void){
  Case* c = (Case *)malloc(sizeof(Case));
  c->colonie = NULL;
  c->occupant = NULL;
  return c;
}

typedef struct {
  int x,y;
}Point;


//créer un plateau de 18/12 de case alloué
void init_tab(Case plateau[LIGNES][COLONNES]){
    for(int i = 0; i<LIGNES;i++){
      for(int j = 0; j<COLONNES ; j++){
        plateau[i][j] = *init_case();
      }
    }
}
// Unite *nid0 = piece(FRELONCAMP,NID,0,17,11,' ',0,0);
//alloue chaque piece et renvoit un pointeur sur celle ci
Unite* piece(char camp,char type,int force,int posx,int posy,char production,int temps,int toursrestant){
  Unite *r = (Unite *)malloc(sizeof(Unite));
  if(r == NULL) return NULL;
  r->camp = camp;
  r->type = type;
  r->force = force;
  r->posx = posx;
  r->posy = posy;
  r->destx = -1;
  r->desty = -1;
  r->production = production;
  r->temps = temps;
  r->toursrestant = toursrestant;
  r->usuiv = NULL;
  r->uprec = NULL;
  r->colsuiv = NULL;
  r->colprec = NULL;
  r->vsuiv = NULL;
  r->vprec = NULL;
  return r;
}

//affichage test de liste
void affiche(Unite* liste){
  if(liste == NULL) printf("probleme");
  else {
    printf("%c\n",liste->type);
    printf("%c\n",liste->usuiv->type);
    printf("%c\n",liste->usuiv->usuiv->type);
    printf("%c\n",liste->usuiv->usuiv->usuiv->type);
    printf("%c\n",liste->usuiv->usuiv->usuiv->usuiv->type);
  }
}

//affiche le tableau
void affichage(Grille jeu){
  Unite *tmp;
  
  char place[10] = "     -   ";
  for(int i = 0; i<LIGNES;i++){
    printf("-----------------------------------------------------------------------------------------------------------------------\n");
    for(int j = 0; j<COLONNES;j++){
      place[0] = ' ';
      place[1] = ' ';
      place[2] = ' ';
      place[3] = ' ';
      place[4] = ' ';
      place[6] = ' ';
      place[7] = ' ';
      place[8] = ' ';

      if(jeu.plateau[i][j].colonie != NULL && jeu.plateau[i][j].colonie->type == RUCHE) place[0] = 'R';
      if(jeu.plateau[i][j].colonie != NULL && jeu.plateau[i][j].colonie->type == NID) place[6] = 'N';
      tmp = jeu.plateau[i][j].occupant;
      while(tmp != NULL){
        switch (tmp->type)
        {
        case 'r':
          if(tmp->camp == ABEILLE) place[1] = 'r';
          else place[7] = 'r';
          break;
        case 'f':
          place[8] = 'f';
          break;
        case 'g':
          place[3] = 'g';
          break;
        case 'e':
          place[4] = 'e';
          break;
        case 'o':
          place[2] = 'o';
          break;
        }       
        tmp = tmp->vsuiv;
      }
      printf("%s|",place);
    }
    printf("\n");
  }
}  


//creer un type d'abeille (ruche,reine, ouvriere, gueriere,escadron)
Unite* creer_abeille(char abeille , int ruchex ,int ruchey){ /*Création d'unité coté Abeilles*/
    Unite* nouvelle_abeille;
    switch(abeille){
        case 'R':
        nouvelle_abeille = piece(ABEILLE,RUCHE,0,ruchex,ruchey,' ',1,1);
        break;
        case 'r':
        nouvelle_abeille = piece(ABEILLE,REINE,FREINE,ruchex,ruchey,' ',TREINEA,TREINEA);
        break;
        case 'o':
        nouvelle_abeille = piece(ABEILLE,OUVRIERE,FOUVRIERE,ruchex,ruchey,' ',TOUVRIERE,TOUVRIERE);
        break;
        case 'g':
        nouvelle_abeille = piece(ABEILLE,GUERRIERE,FGUERRIERE,ruchex,ruchey,' ',TGUERRIERE,TGUERRIERE);
        break;
        case 'e':
        nouvelle_abeille = piece(ABEILLE,ESCADRON,FESCADRON,ruchex,ruchey,' ',TESCADRON,TESCADRON);
        break;
    }
    return nouvelle_abeille;
}


//creer des frelons(nid,frelons,reine)
Unite* creer_frelon(char frelon,int ruchex, int ruchey ){ /*Création de d'unité coté Frelons*/
    Unite* nouveau_frelon;
    switch(frelon){
        case 'N':
        nouveau_frelon = piece(FRELONCAMP,NID,0,ruchex,ruchey,' ',1,1);
        break;
        case 'r':
        nouveau_frelon = piece(FRELONCAMP,REINE,FREINE,ruchex,ruchey,' ',TREINEF,TREINEF);
        break;
        case 'f':
        nouveau_frelon = piece(FRELONCAMP,FRELON,FFRELON,ruchex,ruchey,' ',TFRELON,TFRELON);
        break;
    }
    return nouveau_frelon;
}

//deplace une unité precise (PAS TESTER)
void deplacer(Unite* creat){
  //j'ai preferé faire avec un switch, comme ca si on change la condition (genre on passe du scanf à un clique de la souris), on aura juste à changer la manière d'avoir les informations et pas le switch
  printf("Ou voulez vous vous déplacez ? ( NO(Nord-Ouest), N(Nord), NE(Nord-Est), E(Est), SE(Sud-Est), S(Sud), SO(Sud-Ouest), O(Ouest))");
  char deplacement[3] = "";
  do{
  scanf("%s",deplacement);
  }while(deplacement !="NO" || deplacement !="N" || deplacement !="NE" || deplacement !="E"|| deplacement !="SE" || deplacement !="S" || deplacement !="SO"|| deplacement !="O" );
  int cpt=0;
  //vérifie si le coup à bien été joué, si on décide de déplacer une unité, on la déplace obligatoirement
  //on voit si la future position est bien dans le plateau de jeu
  while(cpt==0){
    int tmpx=creat->posx;
    int tmpy=creat->posy;
    if("NO" == deplacement){
      if ((0<=tmpx-1 && tmpx-1<18) && (0<=tmpy-1 && tmpy-1<12)){
        creat->posx = tmpx-1;
        creat->posy = tmpy-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      }
      if ("N" == deplacement){
        if (0<=tmpy-1 && tmpy-1<12){
          creat->posy = tmpy-1;
          cpt+=1;
        } 
        else 
          printf("Impossible d'accéder à cette endroit");
      } 
      if ("NE" == deplacement){
        if ((0<=tmpx+1 && tmpx+1<18) && (0<=tmpy-1 && tmpy-1<12)){
          creat->posx = tmpx+1;
          creat->posy = tmpy-1;
          cpt+=1;
        } 
        else 
          printf("Impossible d'accéder à cette endroit");
      }
      if ("E" == deplacement){
        if (0<=tmpx+1 && tmpx+1<18){
          creat->posx = tmpx+1;
          cpt+=1;
        } 
        else 
          printf("Impossible d'accéder à cette endroit");
      }
      break;
    if ("SE" == deplacement){
      if ((0<=tmpx+1 && tmpx+1<18) && (0<=tmpy+1 && tmpy+1<12)){
        creat->posx = tmpx+1;
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    if ("S" == deplacement){
      if (0<=tmpy+1 && tmpy+1<12){
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    if ("SO" == deplacement){
      if ((0<=tmpx-1 && tmpx-1<18) && (0<=tmpy+1 && tmpy+1<12)){
        creat->posx = tmpx-1;
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    if ("O" == deplacement){
      if (0<=tmpx-1 && tmpx-1<18){
        creat->posx = tmpx-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    }
  }


//pas oublier de quand la récolte est fini, reset la valeur de production
//pas oublier de vérifier apres chaque tour dans le main si toursrestant est égal à 0, si oui, ajouter une ressource pollen et tuer l'ouvriere sans rapporter de ressource au frelon
void recolter_pollen(Unite* creat){
    if(creat->production = ' '){
        creat->production='p'; /*pour pollen*/ 
        creat->destx = -1;
        creat->desty = -1; //immobile quand récolte du pollen, meurt apres donc pas besoin de modif sa valeur
        creat->temps = 4;
        creat->toursrestant = 4;
  }
}


// Utilise le pouvoir d'une Unité
void pouvoir_unite(Unite* creat,int choix ){ /*un nombre entre 0 et 1 pour choisir ce qu'il veut faire (0 se déplacer si il peut, 1 utiliser son pouvoir -1 pour se supprimer sinon skip)*/
char type = creat->type;
    switch(type){
    case 'R':
        if (choix==1){
            char type_voulu;
            printf("Type voulue (r pour reine,o pour ouvriere,g pour guerriere,e pour escouade)\n"); //demande à l'utilisateur le type qu'il veut
            
            do{
            scanf("%s",&type_voulu); /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            } while(type_voulu !='r' || type_voulu !='o' || type_voulu !='g' || type_voulu !='e' );
            //problème ici, je n'utilise pas la partie production de la ruche, je pense pas en avoir besoin comme dans le créer abeille on a un switch en fonction de quelle abeille on veut
            creer_abeille(type_voulu, creat->posx, creat->posy);
        } 
        break;
    case 'N':
        if (choix==1){
            //demande à l'utilisateur le type qu'il veut
            printf("Type voulue (r pour reine,f pour frelon)");
            char type_voulu;
            scanf("%s ",&type_voulu); /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            do{
            }while(type_voulu !='r' || type_voulu !='f');
            creer_frelon(type_voulu, creat->posx, creat->posy);
        }
        break;
    case 'r':
        /* Dans le sujet ils précisent que c'est possible, donc il existe des cas où c'est pas possible donc fonction*/
        if (choix==0)deplacer(creat);
        if (choix==1){
            if(creat->camp == 'A')creer_abeille(NID, creat->posx,creat->posy); 
            if(creat->camp == 'F')creer_frelon(RUCHE, creat->posx,creat->posy);
            }
        break;
    case 'o':
        if (choix==0)deplacer(creat);
        if (choix==1)recolter_pollen(creat);
        break;
    case 'e':
        if (choix==0)deplacer(creat);
        break;
    case 'g':
        if (choix==0)deplacer(creat);
        break;
    case 'f':
        if (choix==0)deplacer(creat);
        break; 
  }
}

//lancer de dé aleatoire
int tire_de(){
  return rand()%60 + 1;
}


//combat entre 2 unités de cmap different
int combat(char abeille,char frelons){ 
  int res1 = tire_de();
  int res2 = tire_de();
  switch (abeille){
  case REINE:
    res1 = res1 * FREINE;
    break;
  
  case OUVRIERE:
    res1 = res1 * FOUVRIERE;
    break;
  
  case GUERRIERE:
    res1 = res1 * FGUERRIERE;
    break;
  
  case ESCADRON:
    res1 = res1 * FESCADRON;
    break;
  
  default:
    res1 = 0;
    break;
  }
  switch (frelons){
  case REINE:
    res2 = res2 * FREINE;
    break;

  case FRELON:
    res2 = res2 * FFRELON;
    break;

  default:
    res2 = 0;
    break;
  }
  return res1-res2;
}

//ajoute une colonie a une case mais aussi dans la liste de ruche ou de nid
void ajoute_colonie(Grille* jeu, Unite* new_occupant, int posx, int posy){
    jeu->plateau[posx][posy].colonie = new_occupant;
    Unite* tmp = jeu->plateau[posx][posy].colonie;
    if(tmp == NULL) jeu->plateau[posx][posy].colonie = new_occupant;
    else {
      while(tmp->colsuiv != NULL){
          tmp = tmp->colsuiv;
      }
      tmp->colsuiv = new_occupant;
      new_occupant->colprec = tmp;
    }
}




//ajoute une Unité a une case du plateau
void ajoute_occupant(Unite** Liste, Unite* new_occupant){    
  Unite* tmp = *Liste;
  if(tmp == NULL) *Liste = new_occupant;
  else {switch (new_occupant->type)
  {
    case ESCADRON:
      new_occupant->vsuiv = tmp;
      tmp->vprec = new_occupant;
      *Liste = new_occupant;
      break;
    case GUERRIERE:
      while(tmp->vsuiv != NULL && tmp->type == ESCADRON){
        tmp = tmp->vsuiv;
      }
      if(tmp->vsuiv == NULL && tmp->vprec == NULL){
        if(tmp->type == ESCADRON){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vsuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->vsuiv == NULL)
      {
        if(tmp->type == ESCADRON){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vprec = tmp->vprec;
          new_occupant->vsuiv = tmp;
          new_occupant->vprec->vsuiv = new_occupant;
          tmp->vprec = new_occupant;
        }
      }
      else if (tmp->vprec == NULL)
      {
        if(tmp->type == ESCADRON){
          new_occupant->vsuiv = tmp->vsuiv;
          new_occupant->vprec = tmp;
          new_occupant->vsuiv->vprec = new_occupant;
          tmp->vsuiv = new_occupant;
        }
        else{
          new_occupant->vsuiv = tmp;
          tmp->vprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->vsuiv = tmp;
        new_occupant->vprec = tmp->vprec;
        tmp->vprec->vsuiv = new_occupant;
        tmp->vprec = new_occupant;
      }
      break;
    case REINE:
      if(new_occupant->camp == ABEILLE){
        while (tmp->vsuiv != NULL && (tmp->type == ESCADRON || tmp->type == GUERRIERE)){
          tmp = tmp->vsuiv;
        }
        if(tmp->vsuiv == NULL && tmp->vprec == NULL){
          if(tmp->type == ESCADRON || tmp->type == GUERRIERE){
            tmp->vsuiv = new_occupant;
            new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vsuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->vsuiv == NULL)
      {
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vprec = tmp->vprec;
          new_occupant->vsuiv = tmp;
          new_occupant->vprec->vsuiv = new_occupant;
          tmp->vprec = new_occupant;
        }
      }
      else if (tmp->vprec == NULL)
      {
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE){
          new_occupant->vsuiv = tmp->vsuiv;
          new_occupant->vprec = tmp;
          new_occupant->vsuiv->vprec = new_occupant;
          tmp->vsuiv = new_occupant;
        }
        else{
          new_occupant->vsuiv = tmp;
          tmp->vprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->vsuiv = tmp;
        new_occupant->vprec = tmp->vprec;
        tmp->vprec->vsuiv = new_occupant;
        tmp->vprec = new_occupant;
      }
      }else while (tmp->vsuiv != NULL && (tmp->type == ESCADRON || tmp->type == GUERRIERE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE))){
          tmp = tmp->vsuiv;
        }
        if(tmp->vsuiv == NULL && tmp->vprec == NULL){
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vsuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->vsuiv == NULL)
      {
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vprec = tmp->vprec;
          new_occupant->vsuiv = tmp;
          new_occupant->vprec->vsuiv = new_occupant;
          tmp->vprec = new_occupant;
        }
      }
      else if (tmp->vprec == NULL)
      {
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          new_occupant->vsuiv = tmp->vsuiv;
          new_occupant->vprec = tmp;
          new_occupant->vsuiv->vprec = new_occupant;
          tmp->vsuiv = new_occupant;
        }
        else{
          new_occupant->vsuiv = tmp;
          tmp->vprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->vsuiv = tmp;
        new_occupant->vprec = tmp->vprec;
        tmp->vprec->vsuiv = new_occupant;
        tmp->vprec = new_occupant;
      }
      break;
    case OUVRIERE:
      while (tmp->vsuiv != NULL && (tmp->type == ESCADRON || tmp->type == GUERRIERE || (tmp->type == REINE && tmp->camp == ABEILLE))){
        tmp = tmp->vsuiv;
      }
      if(tmp->vsuiv == NULL && tmp->vprec == NULL){
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vsuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->vsuiv == NULL)
      {
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->vsuiv = new_occupant;
          new_occupant->vprec = tmp;
        }
        else{
          new_occupant->vprec = tmp->vprec;
          new_occupant->vsuiv = tmp;
          new_occupant->vprec->vsuiv = new_occupant;
          tmp->vprec = new_occupant;
        }
      }
      else if (tmp->vprec == NULL)
      {
        if(tmp->type == ESCADRON || tmp->type == GUERRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          new_occupant->vsuiv = tmp->vsuiv;
          new_occupant->vprec = tmp;
          new_occupant->vsuiv->vprec = new_occupant;
          tmp->vsuiv = new_occupant;
        }
        else{
          new_occupant->vsuiv = tmp;
          tmp->vprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->vsuiv = tmp;
        new_occupant->vprec = tmp->vprec;
        tmp->vprec->vsuiv = new_occupant;
        tmp->vprec = new_occupant;
      }
      break;
    case FRELON:
      while (tmp->vsuiv != NULL ){
        tmp = tmp->vsuiv;
      }
      tmp->vsuiv = new_occupant;
      new_occupant->vprec = tmp;
      break;
    }
    
  }
}

//ajoute une unité a une colonie
void ajoute_unite(Unite** Liste, Unite* new_occupant){
  Unite* tmp = *Liste;
  if(tmp == NULL) *Liste = new_occupant;
  else {switch (new_occupant->type)
  {
    case ESCADRON:
      while (tmp->usuiv != NULL ){
        tmp = tmp->usuiv;
      }
      tmp->usuiv = new_occupant;
      new_occupant->uprec = tmp;

    case GUERRIERE:
      while(tmp->usuiv != NULL && (tmp->type == RUCHE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE))){
        tmp = tmp->usuiv;
      }
      if(tmp->usuiv == NULL && tmp->uprec == NULL){
        if(tmp->type == RUCHE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->usuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->usuiv == NULL)
      {
        if(tmp->type == RUCHE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->uprec = tmp->uprec;
          new_occupant->usuiv = tmp;
          new_occupant->uprec->usuiv = new_occupant;
          tmp->uprec = new_occupant;
        }
      }
      else if (tmp->uprec == NULL)
      {
        if(tmp->type == RUCHE || tmp->type == OUVRIERE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          new_occupant->usuiv = tmp->usuiv;
          new_occupant->uprec = tmp;
          new_occupant->usuiv->uprec = new_occupant;
          tmp->usuiv = new_occupant;
        }
        else{
          new_occupant->usuiv = tmp;
          tmp->uprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->usuiv = tmp;
        new_occupant->uprec = tmp->uprec;
        tmp->uprec->usuiv = new_occupant;
        tmp->uprec = new_occupant;
      }
      break;

    case REINE:
      if(new_occupant->camp == ABEILLE){
        while (tmp->usuiv != NULL && tmp->type == RUCHE){
          tmp = tmp->usuiv;
        }
        if(tmp->usuiv == NULL && tmp->uprec == NULL){
          if(tmp->type == RUCHE){
            tmp->usuiv = new_occupant;
            new_occupant->uprec = tmp;
        }
        else{
          new_occupant->usuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->usuiv == NULL)
      {
        if(tmp->type == RUCHE){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->uprec = tmp->uprec;
          new_occupant->usuiv = tmp;
          new_occupant->uprec->usuiv = new_occupant;
          tmp->uprec = new_occupant;
        }
      }
      else if (tmp->uprec == NULL)
      {
        if(tmp->type == RUCHE){
          new_occupant->usuiv = tmp->usuiv;
          new_occupant->uprec = tmp;
          new_occupant->usuiv->uprec = new_occupant;
          tmp->usuiv = new_occupant;
        }
        else{
          new_occupant->usuiv = tmp;
          tmp->uprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->usuiv = tmp;
        new_occupant->uprec = tmp->uprec;
        tmp->uprec->usuiv = new_occupant;
        tmp->uprec = new_occupant;
      }
      }else 
          while (tmp->usuiv != NULL && tmp->type == NID ){
          tmp = tmp->usuiv;
        }
        if(tmp->usuiv == NULL && tmp->uprec == NULL){
        if(tmp->type == NID){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->usuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->usuiv == NULL)
      {
        if(tmp->type == NID){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->uprec = tmp->uprec;
          new_occupant->usuiv = tmp;
          new_occupant->uprec->usuiv = new_occupant;
          tmp->uprec = new_occupant;
        }
      }
      else if (tmp->uprec == NULL)
      {
        if(tmp->type == NID){
          new_occupant->usuiv = tmp->usuiv;
          new_occupant->uprec = tmp;
          new_occupant->usuiv->uprec = new_occupant;
          tmp->usuiv = new_occupant;
        }
        else{
          new_occupant->usuiv = tmp;
          tmp->uprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->usuiv = tmp;
        new_occupant->uprec = tmp->uprec;
        tmp->uprec->usuiv = new_occupant;
        tmp->uprec = new_occupant;
      }
      break;

    case OUVRIERE:
      while (tmp->usuiv != NULL && (tmp->type == RUCHE || (tmp->type == REINE && tmp->camp == ABEILLE))){
        tmp = tmp->usuiv;
      }
      if(tmp->usuiv == NULL && tmp->uprec == NULL){
        if(tmp->type == RUCHE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->usuiv = tmp;
          *Liste = new_occupant;
        }
      }
      else if (tmp->usuiv == NULL)
      {
        if(tmp->type == RUCHE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          tmp->usuiv = new_occupant;
          new_occupant->uprec = tmp;
        }
        else{
          new_occupant->uprec = tmp->uprec;
          new_occupant->usuiv = tmp;
          new_occupant->uprec->usuiv = new_occupant;
          tmp->uprec = new_occupant;
        }
      }
      else if (tmp->uprec == NULL)
      {
        if(tmp->type == RUCHE || (tmp->type == REINE && tmp->camp == ABEILLE)){
          new_occupant->usuiv = tmp->usuiv;
          new_occupant->uprec = tmp;
          new_occupant->usuiv->uprec = new_occupant;
          tmp->usuiv = new_occupant;
        }
        else{
          new_occupant->usuiv = tmp;
          tmp->uprec = new_occupant;
          *Liste = new_occupant;
        }
      }
      else
      {
        new_occupant->usuiv = tmp;
        new_occupant->uprec = tmp->uprec;
        tmp->uprec->usuiv = new_occupant;
        tmp->uprec = new_occupant;
      }
      break;

    case FRELON:
      while (tmp->usuiv != NULL ){
        tmp = tmp->usuiv;
      }
      tmp->usuiv = new_occupant;
      new_occupant->uprec = tmp;
      break;
    }
    
  }
}


//supprime une colonie du plateau
void supprime_colonie(Unite** Liste, Unite* old_colonie){
  if (old_colonie->colprec==NULL){
    *Liste=old_colonie->colsuiv;
    old_colonie->colsuiv->colprec=NULL;
    old_colonie->colsuiv=NULL;
  }
  if (old_colonie->colsuiv->colprec==NULL){
    old_colonie->colprec->colsuiv=NULL;
    old_colonie->colprec=NULL;
  }
  old_colonie->colprec->colsuiv=old_colonie->colsuiv;
  old_colonie->colsuiv->colprec=old_colonie->colprec;
  old_colonie->colsuiv=NULL;
  old_colonie->colprec=NULL;
  free(old_colonie);
}

//supprime unité du plateau
void supprime_unite(Unite** Liste, Unite* old_unite){
  //pour unite ruche
  if (old_unite->uprec==NULL){
    *Liste=old_unite->usuiv;
    old_unite->usuiv->uprec=NULL;
    old_unite->usuiv=NULL;
  }
  if (old_unite->usuiv->uprec==NULL){
    old_unite->uprec->usuiv=NULL;
    old_unite->uprec=NULL;
  }
  old_unite->uprec->usuiv=old_unite->usuiv;
  old_unite->usuiv->uprec=old_unite->uprec;
  old_unite->usuiv=NULL;
  old_unite->uprec=NULL;
  //pour unite case
  if (old_unite->vprec==NULL){
    *Liste=old_unite->vsuiv;
    old_unite->vsuiv->vprec=NULL;
    old_unite->vsuiv=NULL;
  }
  if (old_unite->vsuiv->vprec==NULL){
    old_unite->vprec->vsuiv=NULL;
    old_unite->vprec=NULL;
  }
  old_unite->vprec->vsuiv=old_unite->vsuiv;
  old_unite->vsuiv->vprec=old_unite->vprec;
  old_unite->vsuiv=NULL;
  old_unite->vprec=NULL;
  free(old_unite);
}

void enleve_occupant(Unite** liste, Unite* unite){//supprime un ocuppant d'une case
  if(unite->vsuiv == NULL && unite->vprec == NULL) *liste = NULL;
  else if(unite->vsuiv == NULL) unite->vprec->vsuiv = NULL;
  else if(unite->vprec == NULL){
    *liste = unite->vsuiv;
    unite->vprec = NULL; 
  }
  else{
    unite->vprec->vsuiv = unite->vsuiv;
    unite->vsuiv->vprec = unite->vprec;
    unite->vprec = NULL;
    unite->vsuiv = NULL;
  }
}

void enleve_colonie(Unite** liste, Unite* unite){//supprime un ocuppant d'une case
  if(unite->usuiv == NULL && unite->uprec == NULL) *liste = NULL;
  else if(unite->usuiv == NULL) unite->uprec->usuiv = NULL;
  else if(unite->uprec == NULL){
    *liste = unite->usuiv;
    unite->uprec = NULL; 
  }
  else{
    unite->uprec->usuiv = unite->usuiv;
    unite->usuiv->uprec = unite->uprec;
    unite->uprec = NULL;
    unite->usuiv = NULL;
  }
}

//initialisation du jeu au depart
void initialisation_jeu(Grille* jeu){
    Unite *R = creer_abeille(RUCHE,0,0);
    Unite *e = creer_abeille(ESCADRON,0,0);
    Unite *g = creer_abeille(GUERRIERE,0,0);
    Unite *o = creer_abeille(OUVRIERE,0,0);
    Unite *ra = creer_abeille(REINE,0,0);

    jeu->abeille = R;
    ajoute_colonie(jeu,R,0,0);
    ajoute_unite(&R,e);
    ajoute_unite(&R,g);
    ajoute_unite(&R,o);
    ajoute_unite(&R,ra);
    affiche(R);
    R->toursrestant = 0;
    e->toursrestant = 0;
    g->toursrestant = 0;
    o->toursrestant = 0;
    ra->toursrestant = 0;
    ajoute_occupant(&jeu->plateau[0][0].occupant,ra);
    ajoute_occupant(&jeu->plateau[0][0].occupant,o);
    ajoute_occupant(&jeu->plateau[0][0].occupant,g);
    ajoute_occupant(&jeu->plateau[0][0].occupant,e);
    Unite *N = creer_frelon(NID,17,11);
    Unite *f1 = creer_frelon(FRELON,17,11);
    Unite *f2 = creer_frelon(FRELON,17,11);
    Unite *rf = creer_frelon(REINE,17,11);
    N->toursrestant = 0;
    f1->toursrestant = 0;
    f2->toursrestant = 0;
    rf->toursrestant = 0;
    jeu->frelon = N;
    ajoute_colonie(jeu,N,17,11);
    ajoute_unite(&N,rf);
    ajoute_unite(&N,f1);
    ajoute_unite(&N,f2);
    ajoute_occupant(&jeu->plateau[17][11].occupant,f1);
    ajoute_occupant(&jeu->plateau[17][11].occupant,f2);
    ajoute_occupant(&jeu->plateau[17][11].occupant,rf);
    jeu->ressourcesAbeille = 10;
    jeu->ressourcesFrelon = 10;
    
}


//verification si il y a un combat sur le plateau a utiliser apres la fin d'un tour
Point verif_combat(Grille jeu){
  Unite *tmp;
  for(int posx; posx<LIGNES; posx++){
    for(int posy; posy<COLONNES; posy++){
      tmp = jeu.plateau[posx][posy].occupant;
      if(tmp == NULL) continue;
      while(tmp->vsuiv != NULL){
        tmp = tmp->vsuiv;
      }
      if(((jeu.plateau[posx][posy].colonie != NULL && jeu.plateau[posx][posy].colonie->camp == ABEILLE) || jeu.plateau[posx][posy].occupant->camp == ABEILLE) && ((jeu.plateau[posx][posy].colonie != NULL && jeu.plateau[posx][posy].colonie->camp == FRELONCAMP) || tmp->camp == FRELONCAMP)){
        Point P = {posx,posy};
        return P;
      }
    }
  }
  Point P = {-1,-1};
  return P;
}

void question(Unite* unit, Grille* jeu){ //pose toute les question du jeux et les executes
  char reponse = ' ';
  int res = 0;
  switch(unit->type){

    case RUCHE :
    
    do{
    printf("Voulez vous crée une nouvelle unité ?(o ou n)\n");
    scanf(" %c",&reponse);
    }while(reponse != 'o' && reponse != 'n');
    if(reponse == 'o'){
      if(unit->toursrestant > 0){
        printf("Vous ne pouvez pas crée une unité\n");
        break;
      }
      else if(unit->camp == ABEILLE){
        do{
          printf("Quel unité voulez vous crée ?('r' pour Reine, 'o' pour ouvriere, 'g' pour gueriere, 'e' pour Escadron ou 'q' pour quitter)\n");
          scanf(" %c",&reponse);
          switch(reponse){
            case 'r':
              if(jeu->ressourcesAbeille < CREINEA){
                printf("Probleme pas assez de Pollen\n");
                reponse = ' '; 
              }
              else{
                Unite* c = creer_abeille(reponse,unit->posx,unit->posy);
                fprintf(stderr,"Pb1");
                ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,c);
                fprintf(stderr,"Pb2");
                ajoute_unite(&jeu->plateau[unit->posx][unit->posy].colonie,c);
                fprintf(stderr,"Pb3");
                jeu->ressourcesAbeille -= CREINEA;
                unit->temps = TREINEA;
                unit->toursrestant = TREINEA;
              }
              break;

            case 'o':
              if(jeu->ressourcesAbeille < COUVRIERE){
                printf("Probleme pas assez de Pollen\n");
                reponse = ' '; 
              }
              else{
                Unite* c = creer_abeille(reponse,unit->posx,unit->posy);
                ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,c);
                ajoute_unite(&jeu->plateau[unit->posx][unit->posy].colonie,c);
                jeu->ressourcesAbeille -= COUVRIERE;
                unit->temps = TOUVRIERE;
                unit->toursrestant = TOUVRIERE;
              }
              break;

            case 'g':
              if(jeu->ressourcesAbeille < CGUERRIERE){
                printf("Probleme pas assez de Pollen\n");
                reponse = ' '; 
              }
              else{
                Unite* c = creer_abeille(reponse,unit->posx,unit->posy);
                ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,c);
                ajoute_unite(&jeu->plateau[unit->posx][unit->posy].colonie,c);
                jeu->ressourcesAbeille -= CGUERRIERE;
                unit->temps = TGUERRIERE;
                unit->toursrestant = TGUERRIERE;
              }
              break;

            case 'e':
              if(jeu->ressourcesAbeille < CESCADRON){
                printf("Probleme pas assez de Pollen\n");
                reponse = ' '; 
              }
              else{
                Unite* c = creer_abeille(reponse,unit->posx,unit->posy);
                ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,c);
                ajoute_unite(&jeu->plateau[unit->posx][unit->posy].colonie,c);
                jeu->ressourcesAbeille -= CESCADRON;
                unit->temps = TESCADRON;
                unit->toursrestant = TESCADRON;
              }
              break;

            case 'q':
              break;
          }
        }while(reponse != 'r' && reponse != 'o' && reponse != 'g' && reponse != 'e' && reponse != 'q');
      }
      else{
        do{
          printf("Quel unité voulez vous crée ?('r' pour Reine, 'f' pour frelon ou 'q' pour quitter)\n");
          scanf(" %c",&reponse);
          switch(reponse){
            case 'r':
            if(jeu->ressourcesAbeille < CREINEF){
              printf("Probleme pas assez de Pollen\n");
              reponse = ' '; 
            }
            else{
              Unite* c = creer_abeille(reponse,unit->posx,unit->posy);
              ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,c);
              ajoute_unite(&jeu->plateau[unit->posx][unit->posy].colonie,c);
              jeu->ressourcesAbeille -= CREINEF;
              unit->temps = TREINEF;
              unit->toursrestant = TREINEF;
            }
            break;

            case 'f':
            if(jeu->ressourcesAbeille < CFRELON){
              printf("Probleme pas assez de Pollen\n");
              reponse = ' '; 
            }
            else{
              Unite* c = creer_abeille(reponse,unit->posx,unit->posy);
              ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,c);
              ajoute_unite(&jeu->plateau[unit->posx][unit->posy].colonie,c);
              jeu->ressourcesAbeille -= CFRELON;
              unit->temps = TFRELON;
              unit->toursrestant = TFRELON;
            }
            break;

            case 'q':
            break;
          }
        }while(reponse != 'r' && reponse != 'f' && reponse != 'q');
      } 
    }
    break;

    case REINE:
    printf("1) Se deplacer vers une case voisine. \n2) Fonder un Nid ou une Ruche.\n3) Passer le tour.\n4) Detruire unité.\n");
    do{
    scanf("%d",&res);
    switch(res){
      case 1:
      enleve_occupant(&jeu->plateau[unit->posx][unit->posy].occupant, unit);
      deplacer(unit);
      ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,unit);
      break;
      case 2:
      if(jeu->plateau[unit->posx][unit->posy].colonie != NULL){
        printf("Une colonie existe deja.");
        res = -1;
      }
      else if(jeu->ressourcesAbeille < CREINEA){
        printf("Vous n'avez pas assez de pollen");
        res = -1;
      }
      else {
        Unite* R= creer_abeille(RUCHE,unit->posx,unit->posy);
        ajoute_colonie(jeu,R,unit->posx,unit->posy);
        Unite* tmp = unit;
        enleve_colonie(&unit->colprec->colsuiv,unit);
        ajoute_unite(&R,unit);
      }
      break;
      case 3:
      break;
      case 4:
      enleve_colonie(&unit->colprec->colsuiv,unit);
      enleve_occupant(&jeu->plateau[unit->posx][unit->posy].occupant, unit);
      free(unit);
      break;
    }
    }while(res < 1 && res > 4);
    break;

    case OUVRIERE:
    if(unit->production == RECOLTE) break;
    printf("1) Se deplacer vers une case voisine. \n2) Récolter du pollen (4 tours)\n3) Detruire unité.\n");
    do{
    scanf("%d",&res);
    switch(res){
      case 1:
      enleve_occupant(&jeu->plateau[unit->posx][unit->posy].occupant, unit);
      deplacer(unit);
      ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,unit);
      break;
      case 2:
      if(jeu->plateau[unit->posx][unit->posy].colonie != NULL) break;
      unit->production = RECOLTE;
      unit->temps = TRECOLTE;
      unit->toursrestant = TRECOLTE;
      break;
      case 3:
      enleve_colonie(&unit->colprec->colsuiv,unit);
      enleve_occupant(&jeu->plateau[unit->posx][unit->posy].occupant, unit);
      free(unit);
      break;
    }
    }while(res < 1 && res > 3);
    break;

    default:
    printf("1) Se deplacer vers une case voisine. \n2) Passer le tour.\n3) Detruire unité.\n");
    do{
    scanf("%d",&res);
    switch(res){
      case 1:
      enleve_occupant(&jeu->plateau[unit->posx][unit->posy].occupant, unit);
      deplacer(unit);
      ajoute_occupant(&jeu->plateau[unit->posx][unit->posy].occupant,unit);
      break;
      case 2:
      break;
      case 3:
      enleve_colonie(&unit->colprec->colsuiv,unit);
      enleve_occupant(&jeu->plateau[unit->posx][unit->posy].occupant, unit);
      free(unit);
      break;
    }
    }while(res < 1 && res > 3);
    break;
  }
}

int main(){
  srand(time(NULL));
  
  Grille jeu;
  Point P;
  int res_combat;

  init_tab(jeu.plateau);
  initialisation_jeu(&jeu);
  affichage(jeu);
  affiche(jeu.abeille);
  char joueur_actuelle;
  if(rand()%2 == 0)joueur_actuelle = ABEILLE;
  else joueur_actuelle = FRELONCAMP;

  //while(jeu.abeille != NULL || jeu.frelon != NULL){}
    
  question(jeu.plateau[0][0].colonie,&jeu);
  return 0;
}
