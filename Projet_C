#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Dimensions de la grille en nombre de cases (origine en haut a gauche) :
#define COLONNES 12
#define LIGNES 18

// Les deux camps :
#define ABEILLE 'A'
#define FRELONCAMP 'F'

// Les types d'unites :
#define REINE 'r'
#define OUVRIERE 'o'
#define ESCADRON 'e'
#define GUERRIERE 'g'
#define FRELON 'f'
#define RUCHE 'R'
#define NID 'N'

// Pour la recolte de pollen
#define RECOLTE 'p'

// Les temps necessaires a la production :
#define TREINEA 8
#define TREINEF 8
#define TOUVRIERE 2
#define TGUERRIERE 4
#define TESCADRON 6
#define TFRELON 5
#define TRECOLTE 4


// Les couts necessaires a la production :
#define CREINEA 7
#define CREINEF 8
#define COUVRIERE 3
#define CGUERRIERE 5
#define CESCADRON 6
#define CFRELON 3
#define CRUCHE 10
#define CNID 10

// La force des unites
#define FREINE 6
#define FOUVRIERE 1
#define FGUERRIERE 5
#define FESCADRON 12
#define FFRELON 8

// La structure Unite :
typedef struct unite {
  char camp; // ABEILLE ou FRELON
  char type; // RUCHE, NID, REINE, OUVRIERE, GUERRIERE, ESCADRON ou FRELON
  int force; // la force de l'unite
  int posx, posy; // position actuelle sur la grille
  int destx, desty; // destination (negatif si immobile)
  char production; // production d'une ruche ou d'un nid et RECOLTE pour la recolte de pollen
  int temps; // nombres de tours total pour cette production
  int toursrestant; // tours restant pour cette production
  struct unite *usuiv, *uprec; // liste des unites affiliees a une ruche ou un nid
  struct unite *colsuiv, *colprec; // liste des autres ruches ou nids (colonies) du même camp
  struct unite *vsuiv, *vprec; // liste des autres unites sur la meme case
} Unite, *UListe;



// La structure Case :
typedef struct {
  Unite *colonie; // S'il y a une ruche ou un nid sur la case
  UListe occupant; // les autres occupants de la case
} Case;

// La structure Grille :
typedef struct {
  Case plateau[LIGNES][COLONNES];
  UListe abeille, frelon;
  int tour; // Numero du tour
  int ressourcesAbeille, ressourcesFrelon;
} Grille;

//alloue une case
Case* init_case(void){
  Case* c = (Case *)malloc(sizeof(Case));
  c->colonie = NULL;
  c->occupant = NULL;
  return c;
}

//créer un plateau de 18/12 de case alloué
void init_tab(Case plateau[LIGNES][COLONNES]){
    for(int i = 0; i<LIGNES;i++){
      for(int j = 0; j<COLONNES ; j++){
        plateau[i][j] = *init_case();
      }
    }
}
// Unite *nid0 = piece(FRELONCAMP,NID,0,17,11,' ',0,0);
//alloue chaque piece et renvoit un pointeur sur celle ci
Unite* piece(char camp,char type,int force,int posx,int posy,char production,int temps,int toursrestant){
  Unite *r = (Unite *)malloc(sizeof(Unite));
  if(r == NULL) return NULL;
  r->camp = camp;
  r->type = type;
  r->force = force;
  r->posx = posx;
  r->posy = posy;
  r->destx = -1;
  r->desty = -1;
  r->production = production;
  r->temps = temps;
  r->toursrestant = toursrestant;
  r->usuiv = NULL;
  r->uprec = NULL;
  r->colsuiv = NULL;
  r->colprec = NULL;
  r->vsuiv = NULL;
  r->vprec = NULL;
  return r;
}

//affiche le tableau
void affichage(Grille jeu){
  for(int i = 0; i<LIGNES;i++){
    printf("------------------------\n");
    for(int j = 0; j<COLONNES;j++){
      if(jeu.plateau[i][j].colonie != NULL) 
        printf("%c,",jeu.plateau[i][j].colonie->type);
      else 
        printf(" ,");
      
    }
    printf("\n");
  }
}

Unite* creer_abeille(char abeille , int ruchex ,int ruchey){/*Création d'unité coté Abeilles*/
    Unite* nouvelle_abeille;
    switch(abeille){
        case 'R':
        nouvelle_abeille = piece(ABEILLE,RUCHE,0,ruchex,ruchey,' ',1,1);
        break;
        case 'r':
        nouvelle_abeille = piece(ABEILLE,FREINE,FREINE,ruchex,ruchey,' ',TREINEA,TREINEA);
        break;
        case 'o':
        nouvelle_abeille = piece(ABEILLE,OUVRIERE,FOUVRIERE,ruchex,ruchey,' ',TOUVRIERE,TOUVRIERE);
        break;
        case 'g':
        nouvelle_abeille = piece(ABEILLE,GUERRIERE,FGUERRIERE,ruchex,ruchey,' ',TGUERRIERE,TGUERRIERE);
        break;
        case 'e':
        nouvelle_abeille = piece(ABEILLE,ESCADRON,FESCADRON,ruchex,ruchey,' ',TESCADRON,TESCADRON);
        break;
    }
    return nouvelle_abeille;
}

Unite* creer_frelon(char frelon,int ruchex, int ruchey ){ /*Création de d'unité coté Frelons*/
    Unite* nouveau_frelon;
    switch(frelon){
        case 'N':
        nouveau_frelon = piece(FRELONCAMP,NID,0,ruchex,ruchey,' ',1,1);
        break;
        case 'r':
        nouveau_frelon = piece(FRELONCAMP,REINE,FREINE,ruchex,ruchey,' ',TREINEF,TREINEF);
        break;
        case 'f':
        nouveau_frelon = piece(FRELONCAMP,FRELON,FFRELON,ruchex,ruchey,' ',TFRELON,TFRELON);
        break;
    }
    return nouveau_frelon;
}

void deplacer(Unite* creat){
  //j'ai preferé faire avec un switch, comme ca si on change la condition (genre on passe du scanf à un clique de la souris), on aura juste à changer la manière d'avoir les informations et pas le switch
  printf("Ou voulez vous vous déplacez ? ( NO(Nord-Ouest), N(Nord), NE(Nord-Est), E(Est), SE(Sud-Est), S(Sud), SO(Sud-Ouest), O(Ouest))");
  char deplacement[3] = "";
  do{
  scanf("%s",&deplacement);
  }while(deplacement !='NO' || deplacement !='N' || deplacement !='NE' || deplacement !='E'|| deplacement !='SE' || deplacement !='S' || deplacement !='SO'|| deplacement !='O' );
  int cpt=0;
  //vérifie si le coup à bien été joué, si on décide de déplacer une unité, on la déplace obligatoirement
  while(cpt==0){
  switch(deplacement[3]){
    case 'NO':
    //on voit si la future position est bien dans le plateau de jeu
      int tmpx=creat->posx;
      int tmpy=creat->posy;
      if ((0<=tmpx-1<18) && (0<=tmpy-1<12)){
        creat->posx = tmpx-1;
        creat->posy = tmpy-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    case 'N':
      if (0<=tmpy-1<12){
        creat->posy = tmpy-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
       break;
    case 'NE':
      if ((0<=tmpx+1<18) && (0<=tmpy-1<12)){
        creat->posx = tmpx+1;
        creat->posy = tmpy-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    case 'E':
      if (0<=tmpx+1<18){
        creat->posx = tmpx+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    case 'SE':
      if ((0<=tmpx+1<18) && (0<=tmpy+1<12)){
        creat->posx = tmpx+1;
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    case 'S':
      if (0<=tmpy+1<12){
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    case 'SO':
      if ((0<=tmpx-1<18) && (0<=tmpy+1<12)){
        creat->posx = tmpx-1;
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    case 'O':
      if (0<=tmpx-1<18){
        creat->posx = tmpx-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      break;
    }
  }
}

//pas oublier de quand la récolte est fini, reset la valeur de production
//pas oublier de vérifier apres chaque tour dans le main si toursrestant est égal à 0, si oui, ajouter une ressource pollen et tuer l'ouvriere sans rapporter de ressource au frelon
void recolter_pollen(Unite* creat){
    if(creat->production = ' '){
        creat->production='p'; /*pour pollen*/ 
        creat->destx = -1;
        creat->desty = -1; //immobile quand récolte du pollen, meurt apres donc pas besoin de modif sa valeur
        creat->temps = 4;
        creat->toursrestant = 4;
  }
}

void pouvoir_unite(Unite* creat,int choix ){ /*un nombre entre 0 et 1 pour choisir ce qu'il veut faire (0 se déplacer si il peut, 1 utiliser son pouvoir sinon pour skip)*/
char type = creat->type;
    switch(type){
    case 'R':
        if (choix==1){
            char type_voulu;
            printf('Type voulue (r pour reine,o pour ouvriere,g pour guerriere,e pour escouade)'); //demande à l'utilisateur le type qu'il veut
            
            do{
            scanf("%s",&type_voulu); /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            } while(type_voulu !='r' || type_voulu !='o' || type_voulu !='g' || type_voulu !='e' );
            //problème ici, je n'utilise pas la partie production de la ruche, je pense pas en avoir besoin comme dans le créer abeille on a un switch en fonction de quelle abeille on veut
            creer_abeille(type_voulu, creat->posx, creat->posy);
        } 
        break;
    case 'N':
        if (choix==1){
            //demande à l'utilisateur le type qu'il veut
            printf('Type voulue (r pour reine,f pour frelon)');
            char type_voulu;
            do{
            scanf("%s ",&type_voulu); /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            }while(type_voulu !='r' || type_voulu !='f');
            creer_frelon(type_voulu, creat->posx, creat->posy);
        }
        break;
    case 'r':
        /* Dans le sujet ils précisent que c'est possible, donc il existe des cas où c'est pas possible donc fonction*/
        if (choix==0)deplacer(creat);
        if (choix==1){
            if(creat->camp == 'A')creer_abeille(NID, creat->posx,creat->posy); 
            if(creat->camp == 'F')creer_frelon(RUCHE, creat->posx,creat->posy);
            }
        break;
    case 'o':
        if (choix==0)deplacer(creat);
        if (choix==1)recolter_pollen(creat);
        break;
    case 'e':
        if (choix==0)deplacer(creat);
        break;
    case 'g':
        if (choix==0)deplacer(creat);
        break;
    case 'f':
        if (choix==0)deplacer(creat);
        break; 
  }
}

int tire_de(){
  return rand()%60 + 1;
}

int combat(char abeille,char frelons){ //combat entre abeille et frelon
  int res1 = tire_de();
  int res2 = tire_de();
  switch (abeille){
  case REINE:
    res1 = res1 * FREINE;
    break;
  
  case OUVRIERE:
    res1 = res1 * FOUVRIERE;
    break;
  
  case GUERRIERE:
    res1 = res1 * FGUERRIERE;
    break;
  
  case ESCADRON:
    res1 = res1 * FESCADRON;
    break;
  
  default:
    res1 = 0;
    break;
  }
  switch (frelons){
  case REINE:
    res2 = res2 * FREINE;
    break;

  case FRELON:
    res2 = res2 * FFRELON;
    break;

  default:
    res2 = 0;
    break;
  }
  return res1-res2;
}

void initialisation_jeu(Grille jeu){
    creer_abeille(RUCHE,0,0);
    creer_abeille(ESCADRON,0,0);
    creer_abeille(GUERRIERE,0,0);
    creer_abeille(OUVRIERE,0,0);
    creer_abeille(REINE,0,0);
    creer_frelon(NID,17,12);
    creer_frelon(FRELON,17,12);
    creer_frelon(FRELON,17,12);
    creer_frelon(REINE,17,12);
}

void ajoute_occupant(Unite* Liste, Unite* new_occupant){
    Unite* tmp = Liste;
    while(tmp->vsuiv == NULL){
        tmp = tmp->vsuiv;
    }
    tmp->vsuiv = new_occupant;
    new_occupant->vprec = tmp;
}

void ajoute_unite(Unite* Liste, Unite* new_unite){
    Unite* tmp = Liste;
    while(tmp->usuiv == NULL){
        tmp = tmp->usuiv;
    }
    tmp->usuiv = new_unite;
    new_unite->uprec = tmp;
}

int main(){
  srand(time(NULL));
  Grille jeu;

  init_tab(jeu.plateau);
  Unite* ruche = creer_abeille(RUCHE,0,0);
  Unite* nid = creer_frelon(NID,17,11);

  
  jeu.plateau[0][0].colonie = ruche;
  jeu.plateau[17][11].colonie = nid;
  int res;
  do{
  res = combat(ESCADRON,FRELON);
  }while (res == 0);
  if(res > 0) printf("Abeille on gagner avec %d d'avance", res);
  else printf("Frelons on gagner avec %d", -res);
  
  return 0;
}
