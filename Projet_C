#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Dimensions de la grille en nombre de cases (origine en haut a gauche) :
#define COLONNES 12
#define LIGNES 18

// Les deux camps :
#define ABEILLE 'A'
#define FRELONCAMP 'F'

// Les types d'unites :
#define REINE 'r'
#define OUVRIERE 'o'
#define ESCADRON 'e'
#define GUERRIERE 'g'
#define FRELON 'f'
#define RUCHE 'R'
#define NID 'N'

// Pour la recolte de pollen
#define RECOLTE 'p'

// Les temps necessaires a la production :
#define TREINEA 8
#define TREINEF 8
#define TOUVRIERE 2
#define TGUERRIERE 4
#define TESCADRON 6
#define TFRELON 5
#define TRECOLTE 4


// Les couts necessaires a la production :
#define CREINEA 7
#define CREINEF 8
#define COUVRIERE 3
#define CGUERRIERE 5
#define CESCADRON 6
#define CFRELON 3
#define CRUCHE 10
#define CNID 10

// La force des unites
#define FREINE 6
#define FOUVRIERE 1
#define FGUERRIERE 5
#define FESCADRON 12
#define FFRELON 8

// La structure Unite :
typedef struct unite {
  char camp; // ABEILLE ou FRELON
  char type; // RUCHE, NID, REINE, OUVRIERE, GUERRIERE, ESCADRON ou FRELON
  int force; // la force de l'unite
  int posx, posy; // position actuelle sur la grille
  int destx, desty; // destination (negatif si immobile)
  char production; // production d'une ruche ou d'un nid et RECOLTE pour la recolte de pollen
  int temps; // nombres de tours total pour cette production
  int toursrestant; // tours restant pour cette production
  struct unite *usuiv, *uprec; // liste des unites affiliees a une ruche ou un nid
  struct unite *colsuiv, *colprec; // liste des autres ruches ou nids (colonies) du même camp
  struct unite *vsuiv, *vprec; // liste des autres unites sur la meme case
} Unite, *UListe;



// La structure Case :
typedef struct {
  Unite *colonie; // S'il y a une ruche ou un nid sur la case
  UListe occupant; // les autres occupants de la case
} Case;

// La structure Grille :
typedef struct {
  Case plateau[LIGNES][COLONNES];
  UListe abeille, frelon;
  int tour; // Numero du tour
  int ressourcesAbeille, ressourcesFrelon;
} Grille;

//alloue une case
Case* init_case(void){
  Case* c = (Case *)malloc(sizeof(Case));
  c->colonie = NULL;
  c->occupant = NULL;
  return c;
}

//créer un plateau de 18/12 de case alloué
void init_tab(Case plateau[LIGNES][COLONNES]){
    for(int i = 0; i<LIGNES;i++){
      for(int j = 0; j<COLONNES ; j++){
        plateau[i][j] = *init_case();
      }
    }
}

//alloue chaque piece et renvoit un pointeur sur celle ci
Unite* piece(char camp,char type,int force,int posx,int posy,int destx,int desty,char production,int temps,int toursrestant,struct unite *usuiv, struct unite *uprec,struct unite *colsuiv,struct unite *colprec,struct unite *vsuiv,struct unite *vprec){
  Unite *r = (Unite *)malloc(sizeof(Unite));
  if(r == NULL) return NULL;
  r->camp = camp;
  r->type = type;
  r->force = force;
  r->posx = posx;
  r->posy = posy;
  r->destx = destx;
  r->desty = desty;
  r->production = production;
  r->temps = temps;
  r->toursrestant = toursrestant;
  r->usuiv = usuiv;
  r->uprec = uprec;
  r->colsuiv = colsuiv;
  r->colprec = colprec;
  r->vsuiv = vsuiv;
  r->vprec = vprec;
  return r;
}

//affiche le tableau
void affichage(Grille jeu){
  for(int i = 0; i<LIGNES;i++){
    printf("------------------------\n");
    for(int j = 0; j<COLONNES;j++){
      if(jeu.plateau[i][j].colonie != NULL) 
        printf("%c,",jeu.plateau[i][j].colonie->type);
      else 
        printf(" ,");
      
    }
    printf("\n");
  }
}

Unite creer_abeille(char abeille /*donne le type de l'abeille(fourni quand tu demandes un type spécifique à la ruche)*/){
  //peut être faire un malloc
  unite* nouvelle_abeille=(Unite *)malloc(sizeof(Unite));
    nouvelle_abeille->camp=ABEILLE
    nouvelle_abeille->*usuiv, *uprec=NULL;/*liste des unites affiliees a une ruche ou un nid*/
    nouvelle_abeille->*colsuiv, *colprec=NULL;/*liste des autres ruches ou nids (colonies) du même camp*/
    nouvelle_abeille->*vsuiv, *vprec=NULL;/*liste des autres unites sur la meme case*/
    switch(abeille){
      case 'r':
        nouvelle_abeille->type=REINE;
        nouvelle_abeille->force=FREINE;
        nouvelle_abeille->posx, posy=0,0;
        nouvelle_abeille->destx, desty=-1,-1;
        nouvelle_abeille->production=''/*pas de production*/
        nouvelle_abeille->temps=TREINEA;
        nouvelle_abeille->toursrestant=TREINEA;
        break;
      case 'o':
        nouvelle_abeille->type=OUVRIERE;
        nouvelle_abeille->force=FOUVRIERE;
        nouvelle_abeille->posx, posy=0,0;
        nouvelle_abeille->destx, desty=-1,-1;
        nouvelle_abeille->production=''/*récolte pas encore*/
        nouvelle_abeille->temps=TOUVRIERE;
        nouvelle_abeille->toursrestant=TOUVRIERE;
        break;
      case 'g':
        nouvelle_abeille->type=GUERRIERE;
        nouvelle_abeille->force=FGUERRIERE;
        nouvelle_abeille->posx, posy=0,0;
        nouvelle_abeille->destx, desty=-1,-1;
        nouvelle_abeille->production=''/*pas de production*/
        nouvelle_abeille->temps=TGUERRIERE;
        nouvelle_abeille->toursrestant=TGUERRIERE;
        break;
      case 'e':
        nouvelle_abeille->type=ESCADRON;
        nouvelle_abeille->force=FESCADRON;
        nouvelle_abeille->posx, posy=0,0;
        nouvelle_abeille->destx, desty=-1,-1;
        nouvelle_abeille->production=''/*pas de production*/
        nouvelle_abeille->temps=TESCADRON;
        nouvelle_abeille->toursrestant=TESCADRON;
        break;
    }
    return nouvelle_abeille;
}

Unite creer_frelon(char frelon /*donne le type du frelon*/){
  //peut être faire un malloc
  unite* nouveau_frelon=(Unite *)malloc(sizeof(Unite));
    nouveau_frelon->camp=FRELONCAMP
    nouveau_frelon->*usuiv, *uprec=NULL;/*liste des unites affiliees a une ruche ou un nid*/
    nouveau_frelon->*colsuiv, *colprec=NULL;/*liste des autres ruches ou nids (colonies) du même camp*/
    nouveau_frelon->*vsuiv, *vprec=NULL;/*liste des autres unites sur la meme case*/
    switch(frelon){
      case 'r':
        nouveau_frelon->type=REINE;
        nouveau_frelon->force=FREINE;
        nouveau_frelon->posx, posy=17,11;
        nouveau_frelon->destx, desty=-1,-1;
        nouveau_frelon->production=''/*pas de production*/
        nouveau_frelon->temps=TREINEF;
        nouveau_frelon->toursrestant=TREINEF;
        break;
      case 'f':
        nouveau_frelon->type=FRELON;
        nouveau_frelon->force=FFRELON;
        nouveau_frelon->posx, posy=17,11;
        nouveau_frelon->destx, desty=-1,-1;
        nouveau_frelon->production=''/*pas de production*/
        nouveau_frelon->temps=TFRELON;
        nouveau_frelon->toursrestant=TFRELON;
        break;
    }
    return nouveau_frelon;
}

void skip_tour(){
  continue;
}


void creer_maison(char camp_qui_joue /*A pour abeille et F pour frelon*/){
  unite* nouvelle_maison=(Unite *)malloc(sizeof(Unite));
  nouvelle_maison->camp=camp_qui_joue;
  nouvelle_maison->force=0;
  nouvelle_maison->posx, posy=NULL;/*endroit ou la reine en question décide de créer la ruche*/
  nouvelle_maison->destx, desty=-1,-1;
  nouvelle_maison->production='';//ne créer pas encore et meme si c'est le cas, cette valeur ne devrait pas bouger
  nouvelle_maison->temps=1; //est créer à la fin du tour
  nouvelle_maison->toursrestant=1;
  switch(camp_qui_joue){
    case 'A':
      nouvelle_maison->type=RUCHE;
      nouvelle_maison->*usuiv, *uprec=NULL;// liste des unites affiliees a une ruche ou un nid
      nouvelle_maison->*colsuiv, *colprec=NULL;// liste des autres ruches ou nids (colonies) du même camp
      nouvelle_maison->*vsuiv, *vprec=NULL;// liste des autres unites sur la meme case
      break;
    case 'F':
      nouvelle_maison->type=NID;
      nouvelle_maison->*usuiv, *uprec=NULL;// liste des unites affiliees a une ruche ou un nid
      nouvelle_maison->*colsuiv, *colprec=NULL;// liste des autres ruches ou nids (colonies) du même camp
      nouvelle_maison->*vsuiv, *vprec=NULL;// liste des autres unites sur la meme case
      break;
  }
}

void deplacer(unite* creat){
  //j'ai preferé faire avec un switch, comme ca si on change la condition (genre on passe du scanf à un clique de la souris), on aura juste à changer la manière d'avoir les informations et pas le switch
  printf("ou voulez vous vous déplacez ? (hg(haut gauche),h(haut),hd(haut droite),d,bd,b,bg,g)");
  char* deplacement;
  scanf("%s",&deplacement)
  while(deplacement !='hg' || deplacement !='h' || deplacement !='hd' || deplacement !='d'|| deplacement !='bd' || deplacement !='b' || deplacement !='bg'|| deplacement !='g' ){
    scanf("%s",&deplacement)
  }
  int cpt=0;
  //vérifie si le coup à bien été joué, si on décide de déplacer une unité, on la déplace obligatoirement
  while(cpt==0){
  switch(deplacement){
    case "hg":
    //on voit si la future position est bien dans le plateau de jeu
      tmpx=creat->posx;
      tmpy=creat->posy;
      if ((0<=tmpx-1<18) && (0<=tmpy-1<18)){
        creat->posx,posy=posx-1,posy-1;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
    case "h":
      tmpy=creat->posy;
      if (0<=tmpy-1<18){
        creat->posx,posy=posx,posy-1;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
       break;
    case "hd":
      tmpx=creat->posx;
      tmpy=creat->posy;
      if ((0<=tmpx+1<18) && (0<=tmpy-1<18)){
        creat->posx,posy=posx+1,posy-1;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
    case "d":
      tmpx=creat->posx;
      if (0<=tmpx-1<18){
        creat->posx,posy=posx+1,posy;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
    case "bd":
      tmpx=creat->posx;
      tmpy=creat->posy;
      if ((0<=tmpx+1<18) && (0<=tmpy+1<18)){
        creat->posx,posy=posx+1,posy+1;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
    case "b":
      tmpy=creat->posy;
      if (0<=tmpy+1<18){
        creat->posx,posy=posx,posy+1;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
    case "bg":
      tmpx=creat->posx;
      tmpy=creat->posy;
      if ((0<=tmpx-1<18) && (0<=tmpy+1<18)){
        creat->posx,posy=posx-1,posy+1;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
    case "g":
      tmpx=creat->posx;
      if (0<=tmpx-1<18){
        creat->posx,posy=posx-1,posy;
        cpt+=1;
      }
      else{
        printf("Impossible d'accéder à cette endroit")
      }
      break;
  }
  }
}

//pas oublier de quand la récolte est fini, reset la valeur de production
//pas oublier de vérifier apres chaque tour dans le main si toursrestant est égal à 0, si oui, ajouter une ressource pollen et tuer l'ouvriere sans rapporter de ressource au frelon
void recolter_pollen(Unite* creat){
    if(creat->production=''){
      creat->production='p'; /*pour pollen*/ 
      creat->destx, desty=-1;-1 //immobile quand récolte du pollen, meurt apres donc pas besoin de modif sa valeur
      creat->temps=4;
      creat->toursrestant=4;
    }
    else{
      printf("récolte déjà en cours");
    }
}

void pouvoir_unite(Unite* creat,int choix /*un nombre entre -1, 0 et 1 pour choisir ce qu'il veut faire (0 se déplacer si il peut, 1 utiliser son pouvoir si il en a et -1 pour skip si il peut)*/){
  char type=creat->type;
    switch(type){
      case 'R':
          if (choix==1){
            //demande à l'utilisateur le type qu'il veut
            printf('Type voulue (r pour reine,o pour ouvriere,g pour guerriere,e pour escouade)')
            char type_voulu;
            scanf("%s",&type_voulu) /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            while(type_voulu !='r' || type_voulu !='o' || type_voulu !='g' || type_voulu !='e' ){
              scanf("%s",&type_voulu)
            }
            //problème ici, je n'utilise pas la partie production de la ruche, je pense pas en avoir besoin comme dans le créer abeille on a un switch en fonction de quelle abeille on veut
            creer_abeille(type_voulu);
          } 
          if (choix==-1)skip_tour();
          break;
      case 'N':
          if (choix==1){
            //demande à l'utilisateur le type qu'il veut
            printf('Type voulue (r pour reine,f pour frelon)')
            char type_voulu;
            scanf("%s",&type_voulu) /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            while(type_voulu !='r' || type_voulu !='f'){
              scanf("%s",&type_voulu)
            }
            creer_frelon(type_voulu);
          }
          if (choix==-1)skip_tour();
          break;
      case 'r':
          if (choix==0)deplacer(creat);
          if (choix==1)creer_maison( camp qui joue/*ruche ou nid en fonction du type de reine*/);
          if (choix==-1)skip_tour();/*dans le sujet ils précisent que c'est possible, donc il existe des cas où c'est pas possible donc fonction*/
          break;
      case 'e':
          if (choix==0)deplacer(creat);
          if (choix==-1)skip_tour();
          break;
      case 'g':
          if (choix==0)deplacer(creat);
          if (choix==-1)skip_tour();
          break;
      case 'f':
          if (choix==0)deplacer(creat);
          if (choix==-1)skip_tour();
          break; 
      case 'o':
          if (choix==0)deplacer(creat);
          if (choix==1)recolter_pollen();
          break;
  }
}


//combat entre abeille et frelon
int tire_de(){
  return rand()%60 + 1;
}

int combat(char abeille,char frelons){
  int res1 = tire_de();
  int res2 = tire_de();
  switch (abeille)
  {
  case REINE:
    res1 = res1 * FREINE;
    break;
  
  case OUVRIERE:
    res1 = res1 * FOUVRIERE;
    break;
  
  case GUERRIERE:
    res1 = res1 * FGUERRIERE;
    break;
  
  case ESCADRON:
    res1 = res1 * FESCADRON;
    break;
  
  default:
    res1 = 0;
    break;
  }
  switch (frelons)
  {
  case REINE:
    res2 = res2 * FREINE;
    break;

  case FRELON:
    res2 = res2 * FFRELON;
    break;

  default:
    res2 = 0;
    break;
  }
  return res1-res2;
}

int main(){
  srand(time(NULL));
  Grille jeu;
  Unite *ruche0 = piece(ABEILLE,RUCHE,0,0,0,-1,-1,RUCHE,0,0,NULL,NULL,NULL,NULL,NULL,NULL);
  Unite *nid0 = piece(FRELONCAMP,NID,0,17,11,-1,-1,NID,0,0,NULL,NULL,NULL,NULL,NULL,NULL);



  init_tab(jeu.plateau);
  
  jeu.plateau[0][0].colonie = ruche0;
  jeu.plateau[17][11].colonie = nid0;
  int res;
  do{
  res = combat(ESCADRON,FRELON);
  }while (res == 0);
  if(res > 0) printf("Abeille on gagner avec %d d'avance", res);
  else printf("Frelons on gagner avec %d", -res);
  
  return 0;
}
