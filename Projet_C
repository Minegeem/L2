#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Dimensions de la grille en nombre de cases (origine en haut a gauche) :
#define COLONNES 12
#define LIGNES 18

// Les deux camps :
#define ABEILLE 'A'
#define FRELONCAMP 'F'

// Les types d'unites :
#define REINE 'r'
#define OUVRIERE 'o'
#define ESCADRON 'e'
#define GUERRIERE 'g'
#define FRELON 'f'
#define RUCHE 'R'
#define NID 'N'

// Pour la recolte de pollen
#define RECOLTE 'p'

// Les temps necessaires a la production :
#define TREINEA 8
#define TREINEF 8
#define TOUVRIERE 2
#define TGUERRIERE 4
#define TESCADRON 6
#define TFRELON 5
#define TRECOLTE 4


// Les couts necessaires a la production :
#define CREINEA 7
#define CREINEF 8
#define COUVRIERE 3
#define CGUERRIERE 5
#define CESCADRON 6
#define CFRELON 3
#define CRUCHE 10
#define CNID 10

// La force des unites
#define FREINE 6
#define FOUVRIERE 1
#define FGUERRIERE 5
#define FESCADRON 12
#define FFRELON 8

// La structure Unite :
typedef struct unite {
  char camp; // ABEILLE ou FRELON
  char type; // RUCHE, NID, REINE, OUVRIERE, GUERRIERE, ESCADRON ou FRELON
  int force; // la force de l'unite
  int posx, posy; // position actuelle sur la grille
  int destx, desty; // destination (negatif si immobile)
  char production; // production d'une ruche ou d'un nid et RECOLTE pour la recolte de pollen
  int temps; // nombres de tours total pour cette production
  int toursrestant; // tours restant pour cette production
  struct unite *usuiv, *uprec; // liste des unites affiliees a une ruche ou un nid
  struct unite *colsuiv, *colprec; // liste des autres ruches ou nids (colonies) du même camp
  struct unite *vsuiv, *vprec; // liste des autres unites sur la meme case
} Unite, *UListe;



// La structure Case :
typedef struct {
  Unite *colonie; // S'il y a une ruche ou un nid sur la case
  UListe occupant; // les autres occupants de la case
} Case;

// La structure Grille :
typedef struct {
  Case plateau[LIGNES][COLONNES];
  UListe abeille, frelon;
  int tour; // Numero du tour
  int ressourcesAbeille, ressourcesFrelon;
} Grille;

//alloue une case
Case* init_case(void){
  Case* c = (Case *)malloc(sizeof(Case));
  c->colonie = NULL;
  c->occupant = NULL;
  return c;
}

//créer un plateau de 18/12 de case alloué
void init_tab(Case plateau[LIGNES][COLONNES]){
    for(int i = 0; i<LIGNES;i++){
      for(int j = 0; j<COLONNES ; j++){
        plateau[i][j] = *init_case();
      }
    }
}
// Unite *nid0 = piece(FRELONCAMP,NID,0,17,11,' ',0,0);
//alloue chaque piece et renvoit un pointeur sur celle ci
Unite* piece(char camp,char type,int force,int posx,int posy,char production,int temps,int toursrestant){
  Unite *r = (Unite *)malloc(sizeof(Unite));
  if(r == NULL) return NULL;
  r->camp = camp;
  r->type = type;
  r->force = force;
  r->posx = posx;
  r->posy = posy;
  r->destx = -1;
  r->desty = -1;
  r->production = production;
  r->temps = temps;
  r->toursrestant = toursrestant;
  r->usuiv = NULL;
  r->uprec = NULL;
  r->colsuiv = NULL;
  r->colprec = NULL;
  r->vsuiv = NULL;
  r->vprec = NULL;
  return r;
}

//affiche le tableau
void affichage(Grille jeu){
  Unite *tmp;
  int e,g,ra,o,rf,f,rr,n;
  for(int i = 0; i<LIGNES;i++){
    printf("-------------------------------------------------------------------------------------------\n");

    for(int j = 0; j<COLONNES;j++){
    
      e = 0;
      g = 0;
      ra = 0;
      o = 0;
      rf = 0;
      f = 0;
      rr = 0;
      n = 0;
   
      if(jeu.plateau[i][j].colonie != NULL && jeu.plateau[i][j].colonie->type == RUCHE && rr == 0) 
        printf("R");
      else 
        printf(" ");

     
      tmp = jeu.plateau[i][j].occupant;
      
      while(tmp != NULL){
     
        if (tmp->camp == ABEILLE){
          if(tmp->type == 'r'){
            if(ra == 0){
              printf("r");
              ra++;
            }else{
              printf(" ");
              ra++;
            }  
          }else if(tmp->type == 'o'){
            if(o == 0){
              printf("o");
              o++;
            }else{
              printf(" ");
              o++;
            }
          }
          else if(tmp->type == 'g'){
            if(g == 0){
              printf("g");
              g++;
            }else{
              printf(" ");
              g++;
            }
          }
          else if(tmp->type == 'e'){
            if(e == 0){
              printf("e");
              e++;
            }else{
              printf(" ");
              e++;
            }
          }
        }
        tmp = tmp->vsuiv;
      }
   
      printf("-");

      if(jeu.plateau[i][j].colonie != NULL && jeu.plateau[i][j].colonie->type == NID && n == 0) 
        printf("N");
      else 
        printf(" ");
     
      tmp = jeu.plateau[i][j].occupant;
      while(tmp != NULL){
        if (jeu.plateau[i][j].occupant->camp == FRELONCAMP){
          if(jeu.plateau[i][j].occupant->type == 'r' && rf == 0){
            printf("r");
              rf++;
          }else{
            printf(" ");
            rf++;
          }
          if(jeu.plateau[i][j].occupant->type == 'f' && f == 0){
            printf("f");
              f++;
          }else{
            printf(" ");
            f++;
          }
        }
        tmp = tmp->vsuiv;
        
      }
      printf("|");
    
    }
    printf("\n");
   
  }
}


Unite* creer_abeille(char abeille , int ruchex ,int ruchey){ /*Création d'unité coté Abeilles*/
    Unite* nouvelle_abeille;
    switch(abeille){
        case 'R':
        nouvelle_abeille = piece(ABEILLE,RUCHE,0,ruchex,ruchey,' ',1,1);
        break;
        case 'r':
        nouvelle_abeille = piece(ABEILLE,FREINE,FREINE,ruchex,ruchey,' ',TREINEA,TREINEA);
        break;
        case 'o':
        nouvelle_abeille = piece(ABEILLE,OUVRIERE,FOUVRIERE,ruchex,ruchey,' ',TOUVRIERE,TOUVRIERE);
        break;
        case 'g':
        nouvelle_abeille = piece(ABEILLE,GUERRIERE,FGUERRIERE,ruchex,ruchey,' ',TGUERRIERE,TGUERRIERE);
        break;
        case 'e':
        nouvelle_abeille = piece(ABEILLE,ESCADRON,FESCADRON,ruchex,ruchey,' ',TESCADRON,TESCADRON);
        break;
    }
    return nouvelle_abeille;
}

Unite* creer_frelon(char frelon,int ruchex, int ruchey ){ /*Création de d'unité coté Frelons*/
    Unite* nouveau_frelon;
    switch(frelon){
        case 'N':
        nouveau_frelon = piece(FRELONCAMP,NID,0,ruchex,ruchey,' ',1,1);
        break;
        case 'r':
        nouveau_frelon = piece(FRELONCAMP,REINE,FREINE,ruchex,ruchey,' ',TREINEF,TREINEF);
        break;
        case 'f':
        nouveau_frelon = piece(FRELONCAMP,FRELON,FFRELON,ruchex,ruchey,' ',TFRELON,TFRELON);
        break;
    }
    return nouveau_frelon;
}

void deplacer(Unite* creat){
  //j'ai preferé faire avec un switch, comme ca si on change la condition (genre on passe du scanf à un clique de la souris), on aura juste à changer la manière d'avoir les informations et pas le switch
  printf("Ou voulez vous vous déplacez ? ( NO(Nord-Ouest), N(Nord), NE(Nord-Est), E(Est), SE(Sud-Est), S(Sud), SO(Sud-Ouest), O(Ouest))");
  char deplacement[3] = "";
  do{
  scanf("%s",deplacement);
  }while(deplacement !="NO" || deplacement !="N" || deplacement !="NE" || deplacement !="E"|| deplacement !="SE" || deplacement !="S" || deplacement !="SO"|| deplacement !="O" );
  int cpt=0;
  //vérifie si le coup à bien été joué, si on décide de déplacer une unité, on la déplace obligatoirement
  //on voit si la future position est bien dans le plateau de jeu
  while(cpt==0){
    int tmpx=creat->posx;
    int tmpy=creat->posy;
    if("NO" == deplacement){
      if ((0<=tmpx-1 && tmpx-1<18) && (0<=tmpy-1 && tmpy-1<12)){
        creat->posx = tmpx-1;
        creat->posy = tmpy-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
      }
      if ("N" == deplacement){
        if (0<=tmpy-1 && tmpy-1<12){
          creat->posy = tmpy-1;
          cpt+=1;
        } 
        else 
          printf("Impossible d'accéder à cette endroit");
      } 
      if ("NE" == deplacement){
        if ((0<=tmpx+1 && tmpx+1<18) && (0<=tmpy-1 && tmpy-1<12)){
          creat->posx = tmpx+1;
          creat->posy = tmpy-1;
          cpt+=1;
        } 
        else 
          printf("Impossible d'accéder à cette endroit");
      }
      if ("E" == deplacement){
        if (0<=tmpx+1 && tmpx+1<18){
          creat->posx = tmpx+1;
          cpt+=1;
        } 
        else 
          printf("Impossible d'accéder à cette endroit");
      }
      break;
    if ("SE" == deplacement){
      if ((0<=tmpx+1 && tmpx+1<18) && (0<=tmpy+1 && tmpy+1<12)){
        creat->posx = tmpx+1;
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    if ("S" == deplacement){
      if (0<=tmpy+1 && tmpy+1<12){
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    if ("SO" == deplacement){
      if ((0<=tmpx-1 && tmpx-1<18) && (0<=tmpy+1 && tmpy+1<12)){
        creat->posx = tmpx-1;
        creat->posy = tmpy+1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    if ("O" == deplacement){
      if (0<=tmpx-1 && tmpx-1<18){
        creat->posx = tmpx-1;
        cpt+=1;
      } 
      else 
        printf("Impossible d'accéder à cette endroit");
    }
    }
  }


//pas oublier de quand la récolte est fini, reset la valeur de production
//pas oublier de vérifier apres chaque tour dans le main si toursrestant est égal à 0, si oui, ajouter une ressource pollen et tuer l'ouvriere sans rapporter de ressource au frelon
void recolter_pollen(Unite* creat){
    if(creat->production = ' '){
        creat->production='p'; /*pour pollen*/ 
        creat->destx = -1;
        creat->desty = -1; //immobile quand récolte du pollen, meurt apres donc pas besoin de modif sa valeur
        creat->temps = 4;
        creat->toursrestant = 4;
  }
}

void pouvoir_unite(Unite* creat,int choix ){ /*un nombre entre 0 et 1 pour choisir ce qu'il veut faire (0 se déplacer si il peut, 1 utiliser son pouvoir sinon pour skip)*/
char type = creat->type;
    switch(type){
    case 'R':
        if (choix==1){
            char type_voulu;
            printf("Type voulue (r pour reine,o pour ouvriere,g pour guerriere,e pour escouade)"); //demande à l'utilisateur le type qu'il veut
            
            do{
            scanf("%s",&type_voulu); /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            } while(type_voulu !='r' || type_voulu !='o' || type_voulu !='g' || type_voulu !='e' );
            //problème ici, je n'utilise pas la partie production de la ruche, je pense pas en avoir besoin comme dans le créer abeille on a un switch en fonction de quelle abeille on veut
            creer_abeille(type_voulu, creat->posx, creat->posy);
        } 
        break;
    case 'N':
        if (choix==1){
            //demande à l'utilisateur le type qu'il veut
            printf("Type voulue (r pour reine,f pour frelon)");
            char type_voulu;
            do{
            scanf("%s ",&type_voulu); /* %s ici pour éviter les erreurs si l'utilisateur met plus d'un caractère*/
            }while(type_voulu !='r' || type_voulu !='f');
            creer_frelon(type_voulu, creat->posx, creat->posy);
        }
        break;
    case 'r':
        /* Dans le sujet ils précisent que c'est possible, donc il existe des cas où c'est pas possible donc fonction*/
        if (choix==0)deplacer(creat);
        if (choix==1){
            if(creat->camp == 'A')creer_abeille(NID, creat->posx,creat->posy); 
            if(creat->camp == 'F')creer_frelon(RUCHE, creat->posx,creat->posy);
            }
        break;
    case 'o':
        if (choix==0)deplacer(creat);
        if (choix==1)recolter_pollen(creat);
        break;
    case 'e':
        if (choix==0)deplacer(creat);
        break;
    case 'g':
        if (choix==0)deplacer(creat);
        break;
    case 'f':
        if (choix==0)deplacer(creat);
        break; 
  }
}

int tire_de(){
  return rand()%60 + 1;
}

int combat(char abeille,char frelons){ //combat entre abeille et frelon
  int res1 = tire_de();
  int res2 = tire_de();
  switch (abeille){
  case REINE:
    res1 = res1 * FREINE;
    break;
  
  case OUVRIERE:
    res1 = res1 * FOUVRIERE;
    break;
  
  case GUERRIERE:
    res1 = res1 * FGUERRIERE;
    break;
  
  case ESCADRON:
    res1 = res1 * FESCADRON;
    break;
  
  default:
    res1 = 0;
    break;
  }
  switch (frelons){
  case REINE:
    res2 = res2 * FREINE;
    break;

  case FRELON:
    res2 = res2 * FFRELON;
    break;

  default:
    res2 = 0;
    break;
  }
  return res1-res2;
}


void ajoute_colonie(Grille* jeu,Unite** Liste,Unite* new_occupant,int posx,int posy){
    jeu->plateau[posx][posy].colonie = new_occupant;
    Unite* tmp = *Liste;
    if(tmp == NULL) *Liste = new_occupant;
    else{  
      while(tmp->colsuiv != NULL){
          tmp = tmp->colsuiv;
      }
      tmp->colsuiv = new_occupant;
      new_occupant->colprec = tmp;
    }
}

void ajoute_occupant(Unite** Liste, Unite* new_occupant){
    Unite* tmp = *Liste;
    if(tmp == NULL) *Liste = new_occupant;
    else{  
      while(tmp->vsuiv != NULL){
          tmp = tmp->vsuiv;
      }
      tmp->vsuiv = new_occupant;
      new_occupant->vprec = tmp;
    }
}

void ajoute_unite(Unite* Liste, Unite* new_unite){
    Unite* tmp = Liste;
    while(tmp->usuiv != NULL){
        tmp = tmp->usuiv;
    }
    tmp->usuiv = new_unite;
    new_unite->uprec = tmp;
}

// La structure Unite :
typedef struct unite {
  char camp; // ABEILLE ou FRELON
  char type; // RUCHE, NID, REINE, OUVRIERE, GUERRIERE, ESCADRON ou FRELON
  int force; // la force de l'unite
  int posx, posy; // position actuelle sur la grille
  int destx, desty; // destination (negatif si immobile)
  char production; // production d'une ruche ou d'un nid et RECOLTE pour la recolte de pollen
  int temps; // nombres de tours total pour cette production
  int toursrestant; // tours restant pour cette production
  struct unite *usuiv, *uprec; // liste des unites affiliees a une ruche ou un nid
  struct unite *colsuiv, *colprec; // liste des autres ruches ou nids (colonies) du même camp
  struct unite *vsuiv, *vprec; // liste des autres unites sur la meme case
} Unite, *UListe;


void supprime_colonie(Unite** Liste, Unite* old_colonie){
  if (old_colonie->colprec==NULL){
    *Liste=old_colonie->colsuiv;
    old_colonie->colsuiv->colprec=NULL;
    old_colonie->colsuiv=NULL;
  }
  if (old_colonie->colsuiv->colprec==NULL){
    old_colonie->colprec->colsuiv=NULL;
    old_colonie->colprec=NULL;
  }
  old_colonie->colprec->colsuiv=old_colonie->colsuiv;
  old_colonie->colsuiv->colprec=old_colonie->colprec;
  old_colonie->colsuiv=NULL;
  old_colonie->colprec=NULL;
  free(old_colonie);
}

void supprime_unite(Unite** Liste, Unite* old_unite){
  //pour unite ruche
  if (old_unite->uprec==NULL){
    *Liste=old_unite->usuiv;
    old_unite->usuiv->uprec=NULL;
    old_unite->usuiv=NULL;
  }
  if (old_unite->usuiv->uprec==NULL){
    old_unite->uprec->usuiv=NULL;
    old_unite->uprec=NULL;
  }
  old_unite->uprec->usuiv=old_unite->usuiv;
  old_unite->usuiv->uprec=old_unite->uprec;
  old_unite->usuiv=NULL;
  old_unite->uprec=NULL;
  //pour unite case
  if (old_unite->vprec==NULL){
    *Liste=old_unite->vsuiv;
    old_unite->vsuiv->vprec=NULL;
    old_unite->vsuiv=NULL;
  }
  if (old_unite->vsuiv->vprec==NULL){
    old_unite->vprec->vsuiv=NULL;
    old_unite->vprec=NULL;
  }
  old_unite->vprec->vsuiv=old_unite->vsuiv;
  old_unite->vsuiv->vprec=old_unite->vprec;
  old_unite->vsuiv=NULL;
  old_unite->vprec=NULL;
  free(old_unite);
}

void initialisation_jeu(Grille* jeu){
    Unite *R = creer_abeille(RUCHE,0,0);
    Unite *e = creer_abeille(ESCADRON,0,0);
    Unite *g = creer_abeille(GUERRIERE,0,0);
    Unite *o = creer_abeille(OUVRIERE,0,0);
    Unite *ra = creer_abeille(REINE,0,0);
    ajoute_colonie(jeu,R,0,0);
    ajoute_unite(R,ra);
    ajoute_unite(R,o);
    ajoute_unite(R,g);
    ajoute_unite(R,e);
    ajoute_occupant(&jeu->plateau[0][0].occupant,ra);
    ajoute_occupant(&jeu->plateau[0][0].occupant,o);
    ajoute_occupant(&jeu->plateau[0][0].occupant,g);
    ajoute_occupant(&jeu->plateau[0][0].occupant,e);
    Unite *N = creer_frelon(NID,17,11);
    Unite *f1 = creer_frelon(FRELON,17,11);
    Unite *f2 = creer_frelon(FRELON,17,11);
    Unite *rf = creer_frelon(REINE,17,11);
    ajoute_colonie(jeu,R,17,12);
    ajoute_unite(N,rf);
    ajoute_unite(N,f1);
    ajoute_unite(N,f2);
    ajoute_occupant(&jeu->plateau[17][11].occupant,f1);
    ajoute_occupant(&jeu->plateau[17][11].occupant,f2);
    ajoute_occupant(&jeu->plateau[17][11].occupant,rf);
}

int main(){
  srand(time(NULL));
  Grille jeu;
  fprintf(stderr,"probleme1\n");
  init_tab(jeu.plateau);
  fprintf(stderr,"probleme2\n");
  initialisation_jeu(&jeu);
  fprintf(stderr,"probleme3\n");
  affichage(jeu);
  fprintf(stderr,"probleme4\n");
  /*int res;
  do{
  res = combat(ESCADRON,FRELON);
  }while (res == 0);
  if(res > 0) printf("Abeille on gagner avec %d d'avance\n", res);
  else printf("Frelons on gagner avec %d\n", -res);
  */
  return 0;
}
